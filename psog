repeat task.wait() until game:IsLoaded()
getgenv().Settings = {

    joinPopularServer = true,

    listedPetIDs = {} -- Cache to track listed pet IDs

}





-- Services

local HttpService = game:GetService("HttpService")

local TeleportService = game:GetService("TeleportService")

local Players = game:GetService("Players")

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local Save = require(game:GetService("ReplicatedStorage").Library.Client.Save)

local inventory = Save.Get()["Inventory"]

local pet = inventory.Pet

local function round(num)
    return math.floor(num + 0.5)
end

-- Table to store adjusted costs and resells
local AdjustedValues = {}

local function GetRap()
    local HttpService = game:GetService("HttpService")

    -- Convert percentage string to a number (e.g., "98%" -> 1.05)
    local function safePercentage(value)
        local num = tonumber(value and value:gsub("%%", "") or "0")
        return num and num / 100 or 0
    end

    -- Fetch RAP data with retries (max 3)
    local function fetchRapData()
        for attempt = 1, 3 do
            local success, response = pcall(function()
                return HttpService:JSONDecode(game:HttpGet("https://petsgo.biggamesapi.io/api/rap"))
            end)

            if success and response and response.data then
                return response.data
            end

            warn(("❌ RAP fetch failed! Attempt %d/3. Retrying in 3s..."):format(attempt))
            task.wait()
        end

        error("❌ Max retries reached! Could not fetch RAP data.")
    end

    local apiData = fetchRapData()
    local Rap_DATABASE = {}

    -- Store RAP values for target items
    for _, item in ipairs(apiData) do
        local config = item.configData
        if not (config and typeof(config) == "table" and not config.sh) then
            continue -- Skip invalid or shiny items
        end

        local petName, rapValue = config.id, item.value
        Rap_DATABASE[petName] = rapValue
    end

    -- Adjust values based on CONFIG.TARGET_ITEMS
    for petName, data in pairs(CONFIG.TARGET_ITEMS) do
        local rapValue = Rap_DATABASE[petName] or 0  -- Default to 0 if not found

        -- Get cost and resell percentages from CONFIG
        local numericCost = safePercentage(data.cost)
        local numericResell = safePercentage(data.resell)

        -- Calculate adjusted values
        local adjustedCost = math.floor(rapValue * numericCost + 0.5)
        local adjustedResell = math.floor(rapValue * numericResell + 0.5)

        -- Store adjusted values
        AdjustedValues[petName] = {
            adjustedCost = adjustedCost,
            adjustedResell = adjustedResell
        }

        -- Print for debugging
    end

    return Rap_DATABASE, AdjustedValues
end





-- Convert gem string (e.g., "4.2m") into a numerical value

local function convertGems(gemsString)

    local num, suffix = gemsString:match("([%d%.]+)([kmb]?)")

    if not num then return 0 end

    

    local number = tonumber(num)

    if suffix == "k" then

        return number * 1100

    elseif suffix == "m" then

        return number * 1100000

    elseif suffix == "b" then

        return number * 1100000000

    end

    return number

end

-- Fetch pet database from API


-- Fetch pet database from API

local function fetchPetsDatabase()

    local success, response = pcall(function()

        local apiResponse = game:HttpGet("https://petsgo.biggamesapi.io/api/collection/Pets")

        return HttpService:JSONDecode(apiResponse)

    end)



    if success and response and response.data then

        local PETS_DATABASE = {}

        local REVERSE_LOOKUP = {}



        for _, item in pairs(response.data) do

            if item.configData and typeof(item.configData) == "table" then

                local assetUrl = item.configData.thumbnail

                local itemName = item.configData.name



                if assetUrl and itemName then

                    PETS_DATABASE[assetUrl] = itemName

                    REVERSE_LOOKUP[itemName] = assetUrl

                end

            end

        end

        return PETS_DATABASE, REVERSE_LOOKUP

    else

        warn("[❌ ERROR] Failed to fetch pets database!")

        return {}, {}

    end

end



local PETS_DATABASE, REVERSE_LOOKUP = fetchPetsDatabase()



local function getAssetIdByName(petName)

    return REVERSE_LOOKUP[petName]

end

local function buyPetByName(petName)
    local assetId = getAssetIdByName(petName)
    if not assetId then 
        warn("Asset ID not found for:", petName)
        return 
    end
    
    -- Get pre-calculated adjusted cost from AdjustedValues
    local targetData = AdjustedValues[petName]
    if not targetData or not targetData.adjustedCost then
        warn("No adjusted cost found for:", petName)
        return
    end
    
    local maxPrice = targetData.adjustedCost  -- Use pre-computed value

    while true do
        local booths = workspace:WaitForChild("__THINGS"):WaitForChild("Booths"):GetChildren()
        for _, booth in ipairs(booths) do
            local ownerID = booth:GetAttribute("Owner")
            local petScroll = booth:FindFirstChild("Pets") and booth.Pets:FindFirstChild("BoothTop") and booth.Pets.BoothTop:FindFirstChild("PetScroll")
            
            if petScroll then
                for _, frame in ipairs(petScroll:GetChildren()) do
                    local itemSlot = frame:FindFirstChild("Holder") and frame.Holder:FindFirstChild("ItemSlot")
                    local buy = frame:FindFirstChild("Buy")
                    if itemSlot and buy then
                        local icon = itemSlot:FindFirstChild("Icon")
                        local price = convertGems(buy.Cost.Text)
                        local assetUrl = icon and icon.Image

                        if assetUrl and assetUrl == assetId and price <= maxPrice then
                            pcall(function()
                                ReplicatedStorage.Network.Booths_RequestPurchase:InvokeServer(ownerID, { [frame.Name] = 1 })
                            

                            end)
                        end
                    end
                end
            end
        end
        task.wait()
    end
end



local function claimRandomBooth()
    local boothSpawns = workspace.TRADING.BoothSpawns:GetChildren()  -- Get all booth spawn points

    -- Iterate through booth spawns and check their attributes
    for _, randomBooth in ipairs(boothSpawns) do
        -- Check if the booth spawn has the required attribute, for example, "Booth" and "Owner"
        if randomBooth:FindFirstChild("Booth") then
            local booth = randomBooth:FindFirstChild("Booth")
            
            -- Ensure the booth is available for claiming (no "Owner" attribute or check custom condition)
            if booth and not booth:GetAttribute("Owner") then
                -- Now, we will use the booth's own ID attribute to claim it
                local boothId = randomBooth:GetAttribute("ID")  -- Assuming the booth has an "ID" attribute for uniqueness
                if boothId then
                    local args = { [1] = boothId }  -- Pass booth ID as argument

                    -- Try claiming the booth using its unique ID
                    pcall(function()
                        -- Invoke the Booth claim remote to claim the booth
                        game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Booths_ClaimBooth"):InvokeServer(unpack(args))
                        return boothId  -- Return the booth ID if successfully claimed
                    end)
                else
                    print("[INFO] Booth spawn", randomBooth.Name, "does not have a valid ID attribute.")
                end
            else
                print("[INFO] Booth", randomBooth.Name, "is not available for claiming.")
            end
        else
            print("[INFO] Booth spawn", randomBooth.Name, "does not have a valid booth object.")
        end
    end
end

-- Function to sell pet with quantity set to 1 (UPDATED)

local function sellPet(petId, resellPrice)
    task.wait(2)
    -- Keep original arguments but use pre-calculated resell price
    local petName = pet[petId].id  -- Get pet name from ID
    local actualPrice = AdjustedValues[petName].adjustedResell

    if Settings.listedPetIDs[petId] then return false end
    
    local args = {
        [1] = petId,
        [2] = actualPrice,  -- Use RAP-based price
        [3] = 1
    }

    -- Keep rest of your original sell function
    local success = pcall(function()
        ReplicatedStorage.Network.Booths_CreateListing:InvokeServer(unpack(args))
    end)
    -- Verify actual removal from inventory

    if success then

        local verify = pcall(function()

            return Save.Get().Inventory.Pet[petId] == nil

        end)

        success = verify

    end
    if success then

        Settings.listedPetIDs[petId] = true

    end

    return success

end



-- Modified findAndAutosellPets
local function findAndAutosellPets()
    for petId, petData in pairs(pet) do
        local petName = petData.id
        if CONFIG.TARGET_ITEMS[petName] then
            task.wait(5)  -- 5 seconds delay before listing the next pet
            local resellPrice = CONFIG.TARGET_ITEMS[petName].adjustedResell
            local success = sellPet(petId, resellPrice)
            task.wait(5)
        end
    end
end

local function nokker()
    -- Get the RemoteFunction for "Travel to Trading Plaza"
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local remoteFunction = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Travel to Trading Plaza")
    
    -- Check if PotionVendingMachine exists
    local potionVendingMachine = workspace:FindFirstChild("MAP") 
                                  and workspace.MAP:FindFirstChild("INTERACT") 
                                  and workspace.MAP.INTERACT:FindFirstChild("Machines") 
                                  and workspace.MAP.INTERACT.Machines:FindFirstChild("PotionVendingMachine")

    if potionVendingMachine then
        -- Fire the remote to teleport if PotionVendingMachine exists
        local args = { [1] = 19006211286 }
        remoteFunction:InvokeServer(unpack(args)) 
       end
end

-- Fixed joinLowPopulationServer
local function joinLowPopulationServer()
    while true do
        task.wait(15)
        local success, response = pcall(function()
            return HttpService:JSONDecode(
                game:HttpGet("https://games.roblox.com/v1/games/" .. tostring(game.PlaceId) .. "/servers/Public?sortOrder=Desc&limit=100")
            )
        end)

        if success and response and response.data then
            for _, server in ipairs(response.data) do
                if server.id ~= game.JobId and server.playing <= 35 then
                    local teleportSuccess = pcall(function()
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, Players.LocalPlayer)
                    end)
                    if teleportSuccess then
                        return
                    end
                end
            end
        end
        task.wait(3)
    end
end


-- Main execution


local isSnipingActive = false  -- Variable to track if sniping is active

function Sniell()
    task.spawn(function() findAndAutosellPets() end)
    task.spawn(function() buyPetByName(petName, maxPrice) end)
end

local function main()
    nokker()

    GetRap()
    while true do
        local currentGems = convertGems(player.PlayerGui.Main.Top.Diamonds.Amount.Text)

        if currentGems >= CONFIG.MIN_GEMS then
            isSnipingActive = true  -- Mark sniping as active

            for petName, data in pairs(CONFIG.TARGET_ITEMS) do
                task.spawn(buyPetByName, petName, data.cost)
            end

            -- Server hop loop for sniping mode
            while isSnipingActive do  -- Keep server hopping only while sniping is active
                task.wait(30)  -- You can adjust this time to suit the need for delay between hops

                joinLowPopulationServer()
            end
        else
            isSnipingActive = false  -- Mark sniping as inactive when in sell mode

            -- Only claim booths and sell pets in sell mode
            claimRandomBooth()  -- This should be called only during sell mode
            task.wait(2)

            -- Sell pets in sell mode
            Sniell()
            task.wait(240)
            joinLowPopulationServer()
        end

        task.wait(60) -- Check every minute
    end
end 

main()
